[
  {
    "objectID": "ws23-24/num/sum.html",
    "href": "ws23-24/num/sum.html",
    "title": "Num Weekly Summary",
    "section": "",
    "text": "W01/VL01\n\ndate:\nsummary:\n\nW01/VL02\n\ndate:\nsummary:\n\nW02/VL03\n\ndate:\nsummary:\n\nW02/VL04:\n\ndate:\nsummary:\n\nW03/VL05\n\ndate: 31/10/2023, Tue\nsummary: \\(LR\\)-Decomposition, uniqueness, existence, algorithm, complexity, error analysis\n\nScript pages: 21 (satz 2.5) - 28 (2.3 Error Analysis of LR)\nLR Zerlegung ist eindeutig\nProduct of two triangular matrices is also triangular (left or right)\nInverse of a triangular matrix is triangular (left or right)\nProduct of two left-triangular matrices with \\(a_{ii} = 1\\) is also a left-triangular matrix with \\(\\tilde{a}_{ii} = 1\\)\n\\(LR\\)-Decomposition method using Gauss decomposition (Alg 2.7) (?).\nExistence of the \\(LR\\)-decomposition (Satz 2.8)\nPractical version of \\(LR\\)-decomposition Algorithm (not Alg 2.7) saves space (Alg 2.9).\nComplexity of Alg 2.9 and solving a LSE (De: LGS)\nError analysis of \\(LR\\)-Decomposition.\n\n\nW03/VL06\n\ndate: 02/11/23, Thu\nsummary: Script 28 - 33. Error estimation of Alg 2.9, forwards and backwards error, conditioning of a function, conditioning number.\n\nError estimation of Alg 2.9 with proof (Lemma 2.13 & Satz 2.14)\nAposteriori error estimation of Alg 2.9 (Satz 2.16)\nrelationship between backwards and forwards error, a python example demonstrating that they aren’t necessarily related (?)\nConditioning of a function (Ch 2.4.1).\nConditioning number\n\n\nW04/VL07\n\ndate: 07/11/23, Tue\nsummary: Script 33 - 42.\n\nQuestion: How much effect does the error in \\(A\\) & \\(b\\) have on the solutuion of an LEQ/LGS?\nConditioning of a matrix & its proof. (Prop 2.20)\nError analysis of LEQ/LGS’s (Ch 2.4.3)\nConvergent Matrix sequences and matrix series (Ch 2.4.4.)\n\nNeumann Series (2.4.9, P:37)\nSpectral radius of a matrix\n\nConvergent Matrix sequences are used in the proof of error estimation of LEQ/LGS’s. Proof of 2.2.1\nPivoting Strategies to increase \\(LR\\)-decomposition algorithm stability (Ch. 2.5) via exchanging rows during the steps of the algorithm.\n\nPermutation Matrix (Def 2.25)\n\n\n\nW04/VL08\n\ndate: 09/11/23, Thu\nsummary: Script 43 - 51\n\nnote: numbering shifted 1 up, due to a new example\nAlg. 2.27: \\(LR\\)-Decomposition with column pivot search.\n\nSatz 2.30: \\(\\forall\\) regular matrix \\(A \\in \\mathbb{R}^{n\\times n}\\, \\exists\\) a Permutations matrix \\(P_{\\pi}\\), s.t \\(LR = P_{\\pi}A\\) and its proof.\nA problematic matrix for this method: Wilkinson matrix. Such problems can be avoided with “Full Pivot Search/Vollpivotsuche”.\nBut fullpivot search has the disatvantageous complexity \\(\\mathcal{O}(n^3)\\)\n\nCholesky Decomposition: An efficient method for Symmetric Positive Definite (SPD) Matrices.\n\nDefinition & Properties of SPD matrices. (Def 2.32 & Satz 2.33)\nSatz 3.34: \\(A\\in\\mathbb{R}^{n\\times n} \\text{\\, SPD \\, }\\Rightarrow \\exists \\text{\\, upper triangular} \\, R\\in \\mathbb{R}^{n\\times n} \\text{\\, s.t.\\, } A = R^TR\\) (Cholesky decomposition)\nProof of Satz 3.34\nAlgorithm for Cholesky Decomposition (Alg 2.35) and its complexity (\\(\\frac{n^3}{3} + \\mathcal{O}(n^2)\\)). (2 times more efficient than usual decommposition)\n\n\\(LR\\)-Decomposition for Band-matrices\n\nSparce matrices (schwach besetzte matrix) \\(\\approx\\) many entries are 0.\nhow sparce matrices are stored efficiently: For example\n\nA = 0 5 0    C = (2, 3) {non-nul columns}\n    0 0 0    R = (1, 3) {non-null rows}\n    0 0 7    X = (5, 7) {actual entries in these coordinates}\n\nDefinition of a band matrix (Def 2.38)\n\\(LR\\)-decomposition for Band matrices.\n\n\n\nW05/VL09\n\ndate: 14.11.23, Tue\nsummary: Skript 51 - 55 (togehter with topics form appendix)\n\nReview of some LA topics (from Appendix):\n\nDef of orthogonal matrix\nDef of unitary matrix\nLemma A.57/Satz A.58: Singular value decomposition (SVD) and its proof.\nProgramming example demonstrating uses of SVD for image compression.\nProp A.61 regarding SVD (?)\n\nIntro to new Ch 3 - Interpolation & Approximation\n\nOverview of different types of interpolating functions: polynomial, rational (polynomial), spline, neural network\nIntro Polynomial Interpolation:\n\nDef of vector space of polynomials of degree \\(n\\): \\(\\mathbb{P}_n\\).\nDef 3.1: Lagrange Interpolation Polynomials\n\n\n\n\nW05/VL10\n\ndate: 16.11.23, Thu\nsummary: Skript: 55 - 64\n\nLagrange interpolation\n\nLagrange polynomials \\(\\{l_i\\}_{i=0\\dots n}\\) Form a basis for \\(\\mathbb{P}_n\\) & its proof.\n\nGeneral interpolation with a general basis \\(\\{b_i\\}_{i=0\\dots n}\\) \\(\\Rightarrow\\) Vandermonde Matrix. note: Vandermonde matrix for Lagrange Basis is simply the identity matrix. Vandermonde matrix is very badly conditioned for the monomial basis \\(\\{x^i\\}_{i=0}^n\\)\nError analysis of Lagrange interpolation. Certain properties of the function that is to be interpolated determine the precision of the error analysis (like the smoothness of the function.) (Satz 3.6)\nNeville’s Schema\n\n\nW06/VL11\n\ndate: 21.11.23, Tue\nsummary: Skript 64 - 71\n\nNewton Interpolation (Ch 3.5)\n\nDividierende Differenzen\nLemma 3.11 and its proof via induction.\n\nIntepolation error\nHermite Interpolation\n(3.7 is skipped)\n3.8 Conditioning and Approximation\nWeierstrass Theorem (3.25)\n\n\nW06/VL12\n\ndate: 23.11.23, Thu\nsummary: Skript 71 - 81\n\nreview of error of polynomial interpolation: Bsp 3.21, 3.22.\nRunge Phenomenon\nWeierstrass Theorem (3.25) and its relationship to polynomial interpolation.\nError of the best approximation (Satz 3.26)\n\nDef 3.23: Lebesgue Constant \\(\\Lambda_n\\)\n\nConditioning of the interpolation, what happens when we interpolate \\(f + \\delta\\) instead of \\(f\\)?\nIf the function is only known to be continuous (but not necessarily differentiable), there is another measure for how strong a function “fluctuates”: Modulus of continuity (Stetigkeitsmodul) (Def 3.27)\nJackson’s Theorem (3.28) given without proof.\nCorollary (3.29) - its proof.\nHow to keep \\(\\Lambda_n\\) small? \\(\\rightarrow\\) Chebyshev Interpolation, Chebyshev Points\n\nGoal: find appropriate points \\(\\{x_i\\}_{i=1\\dots n}\\) s.t. \\(\\Lambda_n\\) is minimal.\nDefinition of Chebyshev Points (Def 3.30): \\(x_i^{(n + 1)} = \\cos{(\\frac{2i + 1}{2n + 2}\\pi)}\\) \nDefinition of Chebyshev Polynomials (Def 3.32)\nLemma 3.33 - some properties of chebyshev polynomials\n\n\n\nW07/VL13\n\ndate: 28.11.23\nsummary: Skript 81 - 96 (some pages were skipped)\n\nClenshaw-Curtis points\nSatz 3.34\nProofs regarding Lebesgue Constats are skipped.\nLemma 3.40:\nSkip until Spline Interpolation\nSpline Interpolation:\n\nError of spline interpolation\nCubic splines"
  },
  {
    "objectID": "ws23-24/ipi/sum.html",
    "href": "ws23-24/ipi/sum.html",
    "title": "IPI Weekly Summary",
    "section": "",
    "text": "Week 1/~\n\ndate:\nsummary:\n\nWeek 1/~\n\ndate:\nsummary:\n\nWeek 2/VL 1\n\ndate:\nsummary:\n\nWeek 2/VL 2:\n\ndate:\nsummary:"
  },
  {
    "objectID": "ws23-24/index.html#courses",
    "href": "ws23-24/index.html#courses",
    "title": "WS 23/24",
    "section": "Courses",
    "text": "Courses\n\nNum\nIPI",
    "crumbs": [
      "Bachelor",
      "WS 23/24"
    ]
  },
  {
    "objectID": "ss24/r/sum.html",
    "href": "ss24/r/sum.html",
    "title": "Weekly Summary",
    "section": "",
    "text": "date:\n\n\n\ndate:"
  },
  {
    "objectID": "ss24/r/sum.html#week-1",
    "href": "ss24/r/sum.html#week-1",
    "title": "Weekly Summary",
    "section": "",
    "text": "date:\n\n\n\ndate:"
  },
  {
    "objectID": "ss24/r/sum.html#week-2",
    "href": "ss24/r/sum.html#week-2",
    "title": "Weekly Summary",
    "section": "Week 2",
    "text": "Week 2\n\nLecture 1\ndate: 22/4/24\n\nresources for R\n\nadvanced R ~ hadley wickham link\nr graphics cookbook link\ntidyverse\n\npackages\n\ninstalling and removing packages, package dependencies; shiny, learnr\nnamespaces and name collisions;\ndatasets package for learning; mtcars, iris\n\nfunction return value and print side effect\nclearing variables with rm(x)\nplotting\n\nbasic data plotting with plot\nbasic function plotting with plot and curve\n\n\n\n\nLecture 2\ndate: 26/4/24\n\ncontent: moodle videos 3 & 4\nr is object oriented - everything is an object\n\nclass vs typeof (small difference)\n\nr is also functional: everything that happens is a function call\n\ndifference between functions and function calls sin vs sin()\n\natomic vectors vs lists\ntype casting\nzero length vectors\nmachine numbers (representation of real numbers in R)\nbig integers - r represents large integers instead of 2’s complement.\nvectors have no dimension, array has one dimension. vectors are not arrays.\nfor data-sets use data-frames like: tibbles, data tables…"
  },
  {
    "objectID": "ss24/r/sum.html#week-3",
    "href": "ss24/r/sum.html#week-3",
    "title": "Weekly Summary",
    "section": "Week 3",
    "text": "Week 3\n\nLecture 1\ndate:\n\n\nLecture 2\ndate: 03/05/24 - Fri\n\nnew features in R\n\nother constructs instead of for loops that are faster\nanonymous functions, lambda notation\ndiscrete probability distributions\nstrings as factors\n.class2 can show all classes to which an object belongs, including implicit classes.\n\nnew features in r 4.1\n\nfactor function behavior\nnative pipe operator, analogous to shell pipes, eliminating the need for magrittr pipes.\nas.vector() removes attributes from a vector, like component names.\ncolon operator precedence.\ntail recursion"
  },
  {
    "objectID": "ss24/r/sum.html#week-1-1",
    "href": "ss24/r/sum.html#week-1-1",
    "title": "Weekly Summary",
    "section": "Week 1",
    "text": "Week 1\n\nLecture 1\ndate:\n\n\nLecture 2\ndate:"
  },
  {
    "objectID": "ss24/r/sum.html#week-1-2",
    "href": "ss24/r/sum.html#week-1-2",
    "title": "Weekly Summary",
    "section": "Week 1",
    "text": "Week 1\n\nLecture 1\ndate:\n\n\nLecture 2\ndate:"
  },
  {
    "objectID": "ss24/r/sum.html#week-1-3",
    "href": "ss24/r/sum.html#week-1-3",
    "title": "Weekly Summary",
    "section": "Week 1",
    "text": "Week 1\n\nLecture 1\ndate:\n\n\nLecture 2\ndate:"
  },
  {
    "objectID": "ss24/r/sum.html#week-1-4",
    "href": "ss24/r/sum.html#week-1-4",
    "title": "Weekly Summary",
    "section": "Week 1",
    "text": "Week 1\n\nLecture 1\ndate:\n\n\nLecture 2\ndate:"
  },
  {
    "objectID": "ss24/r/sum.html#week-1-5",
    "href": "ss24/r/sum.html#week-1-5",
    "title": "Weekly Summary",
    "section": "Week 1",
    "text": "Week 1\n\nLecture 1\ndate:\n\n\nLecture 2\ndate:"
  },
  {
    "objectID": "ss24/r/sum.html#week-1-6",
    "href": "ss24/r/sum.html#week-1-6",
    "title": "Weekly Summary",
    "section": "Week 1",
    "text": "Week 1\n\nLecture 1\ndate:\n\n\nLecture 2\ndate:"
  },
  {
    "objectID": "ss24/r/sum.html#week-1-7",
    "href": "ss24/r/sum.html#week-1-7",
    "title": "Weekly Summary",
    "section": "Week 1",
    "text": "Week 1\n\nLecture 1\ndate:\n\n\nLecture 2\ndate:"
  },
  {
    "objectID": "ss24/r/sum.html#week-1-8",
    "href": "ss24/r/sum.html#week-1-8",
    "title": "Weekly Summary",
    "section": "Week 1",
    "text": "Week 1\n\nLecture 1\ndate:\n\n\nLecture 2\ndate:"
  },
  {
    "objectID": "ss24/r/sum.html#week-1-9",
    "href": "ss24/r/sum.html#week-1-9",
    "title": "Weekly Summary",
    "section": "Week 1",
    "text": "Week 1\n\nLecture 1\ndate:\n\n\nLecture 2\ndate:"
  },
  {
    "objectID": "ss24/r/sum.html#week-1-10",
    "href": "ss24/r/sum.html#week-1-10",
    "title": "Weekly Summary",
    "section": "Week 1",
    "text": "Week 1\n\nLecture 1\ndate:\n\n\nLecture 2\ndate:"
  },
  {
    "objectID": "ss24/r/sum.html#week-1-11",
    "href": "ss24/r/sum.html#week-1-11",
    "title": "Weekly Summary",
    "section": "Week 1",
    "text": "Week 1\n\nLecture 1\ndate:\n\n\nLecture 2\ndate:"
  },
  {
    "objectID": "ss24/r/sum.html#week-1-12",
    "href": "ss24/r/sum.html#week-1-12",
    "title": "Weekly Summary",
    "section": "Week 1",
    "text": "Week 1\n\nLecture 1\ndate:\n\n\nLecture 2\ndate:"
  },
  {
    "objectID": "ss24/oop/sum.html",
    "href": "ss24/oop/sum.html",
    "title": "Weekly Summary",
    "section": "",
    "text": "date:\n\n\n\ndate:"
  },
  {
    "objectID": "ss24/oop/sum.html#week-1",
    "href": "ss24/oop/sum.html#week-1",
    "title": "Weekly Summary",
    "section": "",
    "text": "date:\n\n\n\ndate:"
  },
  {
    "objectID": "ss24/oop/sum.html#week-2",
    "href": "ss24/oop/sum.html#week-2",
    "title": "Weekly Summary",
    "section": "Week 2",
    "text": "Week 2\n\nLecture 1\ndate:\n\n\nLecture 2\ndate: 25/4/24\n\nslides: 27 -\ntesting with googletests\n\ngoogletests has to be cloned into the project as a submodule and build together with your code.\n\ntemplates\ntemplate templates\nrenaming types with typedef\nclasses and structs\n\nessentially the same thing, only difference being the default visibility: public for struct.\naccess specifiers: private, public, protected\nfriend class\nconstructors (they are a little messy in c++ due to legacy code issues)\n\nmove constructor:\nconverting constructors (implicit type conversions) \\(\\rightarrow\\) hard to find bugs.\nexplicit keyword.\nconversion operators.\ndelegating constructors.\n\ndestructors \\(\\rightarrow\\) RAII (resource acquisition if initialization)\nthe rule of zero or five.\nmutable members\nthe singleton pattern (single source of truth)"
  },
  {
    "objectID": "ss24/oop/sum.html#week-3",
    "href": "ss24/oop/sum.html#week-3",
    "title": "Weekly Summary",
    "section": "Week 3",
    "text": "Week 3\n\nLecture 1\ndate: 29/04/24 - Monday\n\nbasic cmake concepts\nSheet 2 execises discussion\n\nbasic googletest inclusion - slides are sufficient\n\npresentation proposal should have a presentation date.\n\n\n\nLecture 2\ndate: 02/05/24 - Thursday\n\nslides: 02 - standard\nreview of past lecture:\n\ntemplates\ntypedef\nclasses & structs\nconstructors\ndestructors: deep copy\n\nfundamental concepts of c++: inheritence\n\nlittle inheritence example\ndeadly diamond of death\ncomposition over inheritence\npublic vs private/protected inheritence\nis-a vs has-a\nSOLID principles\n\ndiscussion of the Liskov Subtitution Principle (LSP)\n\n\nproject structure\n\nheader files, header guards\nsource files separate from headers (templates go against this)\nnamespaces to structure and prevent name clashes\n\nc++ standard library:\n\noverview\nstandard input/output, standard error\ncontainers and companion classes\n\nsequences \\(\\approx\\) arrays: array, vector, deque, list, forward list\ncontainer adaptors stack, queue, priority queue\nassociative containers \\(\\approx\\) hash map: set, multiset, map, multimap\nunsorted associative containers: unordered set/multiset/map/multimap\n\niterators: generalization of pointer concept, they can be dereferenced and advanced to show to the subsequent element\nalgorithms: tailored to dfferent iterator categories, make full use of the capabilities of the container.\n\nfunctional programming examples\n\n\nError Handling:\n\nassert: Run-time sanity check\nstatic_assert: compile check with a similar purpose for template meta programming\nexception: error handling mechanism for situation that should not be the norm\n\ndiscussion of exceptions"
  },
  {
    "objectID": "ss24/oop/sum.html#week-4",
    "href": "ss24/oop/sum.html#week-4",
    "title": "Weekly Summary",
    "section": "Week 4",
    "text": "Week 4\n\nLecture 1\ndate: 06/05/24\n\nslides: 03 - advanced\nInheritence & dynamic polymorphism further discussions.\npolymorphism\n\nstatic polymorphism \\(\\approx\\) early binding\ndynamic polymorphism \\(\\approx\\) late binding\nsimple c++ illustration with the keyword virtual, references etc…\n\nc++ implementation of dynamic polymorphism using vtables (dispatch tables).\ncost of polymorphism\ncopying polymorphic types\n\nabstract base class (with a pure vitual function)\nfactory pattern (it is a creational pattern)\n\n\n\nLecture 2\ndate:\nholiday"
  },
  {
    "objectID": "ss24/oop/sum.html#week-5",
    "href": "ss24/oop/sum.html#week-5",
    "title": "Weekly Summary",
    "section": "Week 5",
    "text": "Week 5\n\nLecture 1\ndate: 13/5/24\n\nsolutions to the exercise sheet 2\npresentations:\n\ngit branches & tags\nIDE’s\nvalgrind\n\n\n\n\nLecture 2\ndate: 16/5/24\n\nc++ 11 features: (slide 95)\n\nautomatic type deduction\ntrailing return type\nmove semantics. Before c++ 11 there were two types of variables:\n\nvalues: assignment creates a new independent entity\nreferences and pointers: assignment creates and alias\ncopy constructor:\n\ndeep copy \\(\\Rightarrow\\) value semantics\nshallow copy \\(\\Rightarrow\\) reference semantics\n\nc++ 11: third type of semantics: move semantics\nforwarding references are not\n\nsmart pointers\n\nunique pointers: unique_ptr\nshared pointers: shared_ptr\nweak pointers (non-owning): weak_ptr\nraw pointer usage should be avoided\nso basically in modern c++ two types of pointers\n\nowning pointers: unique_ptr, shared_ptr\nnon-owning pointers: weak_ptr\n\npitfalls:\n\nlambda expressions & closures: generalization of functors in c++\n\ncurrying: \\((\\mathbb{N} \\times \\mathbb{N}) \\rightarrow \\mathbb{N} \\equiv \\mathbb{N} \\rightarrow (\\mathbb{N} \\rightarrow \\mathbb{N})\\)\nbuilder pattern with lambda functions\n\nrandom number generators\ntime measurement (slide 123)"
  },
  {
    "objectID": "ss24/oop/sum.html#week-6",
    "href": "ss24/oop/sum.html#week-6",
    "title": "Weekly Summary",
    "section": "Week 6",
    "text": "Week 6\n\nLecture 1\ndate: 20/05/24\n\nholiday\n\n\n\nLecture 2\ndate: 23/05/24\n\nsolutions & presentations"
  },
  {
    "objectID": "ss24/oop/sum.html#week-7",
    "href": "ss24/oop/sum.html#week-7",
    "title": "Weekly Summary",
    "section": "Week 7",
    "text": "Week 7\n\nLecture 1\ndate: 05/27/24\n\nreview of c++ 11 features from previews lectures:\n\nauto keyword: when to use it.\nmove constructors and move assignment\nshared pointers, weak pointers, unique pointers.\nlambda expressions, functors.\nrandom number generators\n\nrange based loops\nadvanced topics:\n\ninheritance and dynamic polymorphism\nresource acquisition is initialization (RAII)\ntemplate specialization:\n\nfunction template specialization, vs\nclass template specialization\n\ntemplates vs inheritance\n\nachieving the same effect as dynamic polymorphism with static polymorphisdm \\(\\Rightarrow\\) CRTP (curiously recurring template pattern)\n\n\n\n\n\n\nLecture 2\ndate:"
  },
  {
    "objectID": "ss24/oop/sum.html#week-1-1",
    "href": "ss24/oop/sum.html#week-1-1",
    "title": "Weekly Summary",
    "section": "Week 1",
    "text": "Week 1\n\nLecture 1\ndate:\n\n\nLecture 2\ndate:"
  },
  {
    "objectID": "ss24/oop/sum.html#week-1-2",
    "href": "ss24/oop/sum.html#week-1-2",
    "title": "Weekly Summary",
    "section": "Week 1",
    "text": "Week 1\n\nLecture 1\ndate:\n\n\nLecture 2\ndate:"
  },
  {
    "objectID": "ss24/oop/sum.html#week-1-3",
    "href": "ss24/oop/sum.html#week-1-3",
    "title": "Weekly Summary",
    "section": "Week 1",
    "text": "Week 1\n\nLecture 1\ndate:\n\n\nLecture 2\ndate:"
  },
  {
    "objectID": "ss24/oop/sum.html#week-1-4",
    "href": "ss24/oop/sum.html#week-1-4",
    "title": "Weekly Summary",
    "section": "Week 1",
    "text": "Week 1\n\nLecture 1\ndate:\n\n\nLecture 2\ndate:"
  },
  {
    "objectID": "ss24/oop/sum.html#week-1-5",
    "href": "ss24/oop/sum.html#week-1-5",
    "title": "Weekly Summary",
    "section": "Week 1",
    "text": "Week 1\n\nLecture 1\ndate:\n\n\nLecture 2\ndate:"
  },
  {
    "objectID": "ss24/oop/sum.html#week-1-6",
    "href": "ss24/oop/sum.html#week-1-6",
    "title": "Weekly Summary",
    "section": "Week 1",
    "text": "Week 1\n\nLecture 1\ndate:\n\n\nLecture 2\ndate:"
  },
  {
    "objectID": "ss24/oop/sum.html#week-1-7",
    "href": "ss24/oop/sum.html#week-1-7",
    "title": "Weekly Summary",
    "section": "Week 1",
    "text": "Week 1\n\nLecture 1\ndate:\n\n\nLecture 2\ndate:"
  },
  {
    "objectID": "ss24/oop/sum.html#week-1-8",
    "href": "ss24/oop/sum.html#week-1-8",
    "title": "Weekly Summary",
    "section": "Week 1",
    "text": "Week 1\n\nLecture 1\ndate:\n\n\nLecture 2\ndate:"
  },
  {
    "objectID": "ss24/oop/index.html",
    "href": "ss24/oop/index.html",
    "title": "OOP Sci",
    "section": "",
    "text": "Object Oriented Programming for Scientific Computing",
    "crumbs": [
      "OOP Sci"
    ]
  },
  {
    "objectID": "ss24/oop/index.html#section",
    "href": "ss24/oop/index.html#section",
    "title": "OOP Sci",
    "section": "",
    "text": "weekly summary\nnotes\nsol\nplan\nexam",
    "crumbs": [
      "OOP Sci"
    ]
  },
  {
    "objectID": "ss24/index.html#courses",
    "href": "ss24/index.html#courses",
    "title": "SS 24",
    "section": "Courses",
    "text": "Courses\n\nAlda\nR\nOOP",
    "crumbs": [
      "Bachelor",
      "SS 24"
    ]
  },
  {
    "objectID": "ss24/index.html#time",
    "href": "ss24/index.html#time",
    "title": "SS 24",
    "section": "Time",
    "text": "Time\n\ntimes",
    "crumbs": [
      "Bachelor",
      "SS 24"
    ]
  },
  {
    "objectID": "ss24/alda/plan.html#reading-list",
    "href": "ss24/alda/plan.html#reading-list",
    "title": "Study Plan",
    "section": "Reading List",
    "text": "Reading List\n\nAlgorithms\n\nBasic:\n\nUnderstanding Algorithms. Brunskill\nAlgorithms Unlocked. Cormen\nFirst Course in Algorithms Through Puzzles. Ryuhei Uehara\nGrokking Algorithms. Aditya Bhargava\n\nIntermediate:\n\nDesign and Analysis of Algorithms. Jeffrey Smith\nAlgorithms. Jeff Erickson\nHow to Think About Algorithms. Jeff Edmonds\nProblems on Algorithmics. Ian Perberry\nFundamentals of Algorithmics. Brassard, Bratley.\nAlgorithmen & Datenstrukturen - Grundwerkzeuge. Kurt Melhorn\nLecture Notes on Algorithms. Ian Perberry\nAlgorithm Design. Kleinberg, Tardos\nAlgorithms Illuminated. Roughgarden\nCompared to What. G. J. E. Rawlins\nFoundations of Algorithms. Richard Neapolitan\nData Structurese & Their Algorithms. Harry Lewis, Larry Denenberg\nAlgorithms + Data Structures = Programs. Niklaus Wirth\nAlgorithms and Data Structures - Design, Correctness, Analysis. Jeffrey H. Kingston\nComputer Algorithms. Baase\n\nC++:\n\nData Structures & Problem Solving Using C++. M. A. Weiss\nData Structures & Algorithm Analysis in C++. M. A. Weiss\nData & Algorithms in C++. Drozdek.\nData Structures other Objects using C++. Walter Savitch\nPrinciples of Algorithmic Problem Solving. Johan Sannemo\nGuide to Competitive Programming. Antti Laaksonen\n\nC:\n\nAlgorithms and Data Structures - An Approach in C. Bowman\nFoundations of Computer Science. Aho, Ullman\nPrograms and Datastructures in C. Ameraal\n\nPython:\n\nData Structures and Algorithms Using Python. Rance D. Necaise.\nData Structures & Algorithms in Python. Canning, Broder, Lafore\nCompetitive Programaming with Python. Duerr, Vie\nProblem Solving with Algorithms and Data Structures Using Python. Franklin, Beedle\n\n\n\n\nGraph Theory and Discrete Mathematics\n\nGeneral Discrete Mathematics:\n\nMathematical Structures for Computer Science. Judith Gersting\nDiscrete & Combinatorial Mathematics. Grimaldi\nConcrete Mathematics Knuth\nDiskerte Mathematik fuer Einsteiger. Beutelspacher\nDiscrete Mathematics in Computer Science. Golovnev, Kulikov\n\nGraph Theory Specific\n\nGraph Theory - A Poblem Oriented Approach. Daniel A. Marcus\nAlgorithmic Graph Theory. Alan M. Gibbons\nSets, Puzzles & Postmen. Higgins"
  },
  {
    "objectID": "ss24/alda/exam1.html",
    "href": "ss24/alda/exam1.html",
    "title": "My Uni Notes",
    "section": "",
    "text": "what was asked on the exam:\n\nAdjacency Matrix \\(A\\) of a graph \\(G\\):\n\nwrite the pseudocode for an optimal algorithm that determines the total number of nodes in the graph with equal in- and out-degrees.\nAnalyze the complexity of your algorithm and prove optimality\n\nHeaps\nHashing\n\nOpen hashing. Insert a sequence of elements\nOpen hashing. Delete a sequence of elements\n\nStandard questions for comparing functions asymptotically, determining growth rate of reccurence relations with and without applications of the master theorem, analyzing complexity of short pseudocode algorithms like\nread(t)\nk := 1\ni : = 1\nwhile (k &lt;= t) :\n    i := i + 1\n    k := k + i\nShort proofs of statements regarding (a, b) trees and graphs\nSimple proof by induction problem\nDijkstra shortest path algorithm\n\nwasn’t asked:\n\nsorting\nproblems specifically for divide & conquer / recursion\nproblems specifically for dynamic programming\nlinear programming\napproximation / heuristic algorithms\nalgorithms on strings"
  },
  {
    "objectID": "ss24/alda/exam1.html#alda-sose-24-1st-exam",
    "href": "ss24/alda/exam1.html#alda-sose-24-1st-exam",
    "title": "My Uni Notes",
    "section": "",
    "text": "what was asked on the exam:\n\nAdjacency Matrix \\(A\\) of a graph \\(G\\):\n\nwrite the pseudocode for an optimal algorithm that determines the total number of nodes in the graph with equal in- and out-degrees.\nAnalyze the complexity of your algorithm and prove optimality\n\nHeaps\nHashing\n\nOpen hashing. Insert a sequence of elements\nOpen hashing. Delete a sequence of elements\n\nStandard questions for comparing functions asymptotically, determining growth rate of reccurence relations with and without applications of the master theorem, analyzing complexity of short pseudocode algorithms like\nread(t)\nk := 1\ni : = 1\nwhile (k &lt;= t) :\n    i := i + 1\n    k := k + i\nShort proofs of statements regarding (a, b) trees and graphs\nSimple proof by induction problem\nDijkstra shortest path algorithm\n\nwasn’t asked:\n\nsorting\nproblems specifically for divide & conquer / recursion\nproblems specifically for dynamic programming\nlinear programming\napproximation / heuristic algorithms\nalgorithms on strings"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Uni Notes",
    "section": "",
    "text": "Plan"
  },
  {
    "objectID": "index.html#semesters",
    "href": "index.html#semesters",
    "title": "Uni Notes",
    "section": "Semesters",
    "text": "Semesters\n\nWS 23/24\nSS 24"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "My uni notes & resources"
  },
  {
    "objectID": "plan.html",
    "href": "plan.html",
    "title": "Plan",
    "section": "",
    "text": "Pflicht (total = 54LP)\n\nAlda 8LP\nIBN 8LP\nISW 8LP\nBS (4LP + 2UK) 6LP\nFP 8LP\nBA 12LP\nBK 4LP\n\nWM (total = 22LP)\n\nWM-I 8LP\nWM-II 8LP\nWM-III 6LP\n\nFUK (total = 4LP)\n\nFUK-I (2UK) 2LP\nFUK-II (2UK) 2LP\n\nAG (total: 8LP)\n\nTheoPhys-II 8LP\n\n\nsum total: 88LP\nprogress: 92/180 \\(\\approx\\) 51%\n\n\nVersion 1\n\nSS 24 (total: 16LP)\n\nAlda 8LP\nWM-I 6LP\nFUK-I (2UK) 2LP\n\nWS 24/25 (total: 18LP)\n\nISW 8LP\nWM-II 8LP\nFUK-II (2UK) 2LP\n\nSS 25 (total: 24LP)\n\nFP 8LP\nIBN 8LP\nAG: TheoPhys-II 8LP\n\nWS 25/26 (total: 14LP)\n\nWM-III 8LP\nBS 6LP\n\nSS 26 (total: 16LP)\n\nBA 12LP\nBK 4LP"
  },
  {
    "objectID": "plan.html#to-do-as-of-ss-24",
    "href": "plan.html#to-do-as-of-ss-24",
    "title": "Plan",
    "section": "",
    "text": "Pflicht (total = 54LP)\n\nAlda 8LP\nIBN 8LP\nISW 8LP\nBS (4LP + 2UK) 6LP\nFP 8LP\nBA 12LP\nBK 4LP\n\nWM (total = 22LP)\n\nWM-I 8LP\nWM-II 8LP\nWM-III 6LP\n\nFUK (total = 4LP)\n\nFUK-I (2UK) 2LP\nFUK-II (2UK) 2LP\n\nAG (total: 8LP)\n\nTheoPhys-II 8LP\n\n\nsum total: 88LP\nprogress: 92/180 \\(\\approx\\) 51%\n\n\nVersion 1\n\nSS 24 (total: 16LP)\n\nAlda 8LP\nWM-I 6LP\nFUK-I (2UK) 2LP\n\nWS 24/25 (total: 18LP)\n\nISW 8LP\nWM-II 8LP\nFUK-II (2UK) 2LP\n\nSS 25 (total: 24LP)\n\nFP 8LP\nIBN 8LP\nAG: TheoPhys-II 8LP\n\nWS 25/26 (total: 14LP)\n\nWM-III 8LP\nBS 6LP\n\nSS 26 (total: 16LP)\n\nBA 12LP\nBK 4LP"
  },
  {
    "objectID": "ss24/alda/index.html",
    "href": "ss24/alda/index.html",
    "title": "Alda",
    "section": "",
    "text": "Algorithms and Data Structures",
    "crumbs": [
      "Alda"
    ]
  },
  {
    "objectID": "ss24/alda/index.html#section",
    "href": "ss24/alda/index.html#section",
    "title": "Alda",
    "section": "",
    "text": "weekly summary\nnotes\nsolutions\nplan\nexam",
    "crumbs": [
      "Alda"
    ]
  },
  {
    "objectID": "ss24/alda/sum.html",
    "href": "ss24/alda/sum.html",
    "title": "Weekly Summary",
    "section": "",
    "text": "date:\n\n\n\ndate:"
  },
  {
    "objectID": "ss24/alda/sum.html#week-1",
    "href": "ss24/alda/sum.html#week-1",
    "title": "Weekly Summary",
    "section": "",
    "text": "date:\n\n\n\ndate:"
  },
  {
    "objectID": "ss24/alda/sum.html#week-2",
    "href": "ss24/alda/sum.html#week-2",
    "title": "Weekly Summary",
    "section": "Week 2",
    "text": "Week 2\n\nLecture 1\ndate:\n\n\nLecture 2\ndate: 23/04/24\n\nfachschaft\n\nstapel\nkaffeklatsch\nLernraum - time & place tba (instagram, whatsapp groups)\nRoom: INF 205 Mathematikon\nwebsite\n\ncompiler explorer\nSmall assembly example; modern compilers are very clever at optimizing\nassertions, pre- and post conditions, invariants.\nfast power algorithm, it’s correctness proof\nrules for calculating time complexity of sequential programs\na common reccurence relation pattern that comes up often,\n\n\\[\\begin{align}\nR(n) &= a, &&\\text{if n = 1} \\\\\n     &= cn + d\\cdot R(n/b) &&\\text{if n &gt; 1, divide and conquer}\n\\end{align}\\]\n\ncomplexity of this reccurence relation and its proof\nIntro to Graphs, basic definitions"
  },
  {
    "objectID": "ss24/alda/sum.html#week-3",
    "href": "ss24/alda/sum.html#week-3",
    "title": "Weekly Summary",
    "section": "Week 3",
    "text": "Week 3\n\nLecture 1\ndate:\n\n\nLecture 2\ndate: 30/04/24\n\nsimply linked list\n\nsplicing\n\narrays\n\nassembly realization of array access via the website compiler explorer link with c++ and rust. Differences between c++ and rust.\nmemory allocation in c++ with alloc() and free()\ntime complexity of array memory allocation in c++ with alloc(): an experiment\npushBack() and popBack() for arrays\n\ntheir realization and complexity"
  },
  {
    "objectID": "ss24/alda/sum.html#week-4",
    "href": "ss24/alda/sum.html#week-4",
    "title": "Weekly Summary",
    "section": "Week 4",
    "text": "Week 4\n\nLecture 1\ndate: 6/5/24\n\nintroduction to amortized complexity\n\namortized complexity analysis of pushBack() and popBack() operations: both \\(\\mathcal{O}(1)\\)\n\nstacks and queues - introductory discussions\n\ndouble-ended queues\n\nring buffer implementation of a queue\nintroduction to hashing\n\n\n\nLecture 2\ndate: 07/05/24\n\ndivision by a constant is optimized by the compiler (this cannot be done for division by a variable)\nbook recommendation: Hacker’s Delight\nHashing:\n\nintro & some applications\nsome defs:\n\n\\(M \\subseteq T\\). \\(M\\): set of Elements of a certain type \\(T\\), that we want to store (or have stored) in a table and access via their keys.\n\\(m\\): number of memory slots.\n\\(|M|\\): total number of elements stored in the table.\n\\(\\text{key}: M\\rightarrow Key\\): Function that maps elements to their key values\n\\(Key = im(key) = key[M]\\): the set of key values (the range of the key function)\n\\(h: Key\\rightarrow [0, m)\\): the hashing function that maps key values to memory slots \\(0\\dots m - 1\\).\n\npefect hashing: if there are more memory slots than possible key values, \\(h\\) can map each key to a single slot \\(\\Rightarrow\\) over-optimistic, we don’t have so much memory, since usually \\(|Key|\\gg m\\) (Number of possible key values much greater than number of slots).\nimperfect hashing: \\(\\exists e_1, e_2\\in M\\) s.t. \\(e_1 \\neq e_2\\) but \\(h(key(e_1)) = h(key(e_2))\\). This is called collision.\nclosed hashing: an example for imperfect hashing , where the elements of the table are simply linked lists, supporting the operations:\n\ninsert(e). Insert en element \\(e\\in M\\)\nremove(k). Remove an element \\(e\\) whose key is \\(k\\), returning \\(e\\)\nfind(k): Find element \\(e\\) with the key k, return \\(e\\) if found.\nTime-complexities:\n\ninsert(e): \\(\\mathcal{O}(1)\\)\nremove(k): \\(\\mathcal{O}(\\text{List length})\\)\nfind(k): \\(\\mathcal{O}(\\text{List length})\\)\nworst case: bad hash function that maps all keys to the same slot ! \\(\\Rightarrow \\mathcal{O}(|M|)\\)\n\nStochastic analysis of random hash functions & proofs of (with an introductory discussion of birthday paradox):\n\ntheorem: random hash function is likely to be perfect if \\(m \\in \\Omega(n^2)\\)\ntheorem: random hash functions lead to lists of length \\(\\mathcal{O}(1)\\), if \\(|M| \\in \\mathcal{O}(m)\\)"
  },
  {
    "objectID": "ss24/alda/sum.html#week-5",
    "href": "ss24/alda/sum.html#week-5",
    "title": "Weekly Summary",
    "section": "Week 5",
    "text": "Week 5\n\nLecture 1\ndate: 13/5/24\n\nUniversal hashing functions: definition & Theorem 1 holds also for universal hashing functions\n\nA family of universal hashing functions, proof of theorem 1 for these functions\nanother example for a universal hashing function based on bit matrix multiplication\nexample: tabulation hashing\n\nopen hashing: a different way to resolve collisions, without using linked lists, instead looking for the next free table slot:\n\nadvantage: contigious address values \\(\\Rightarrow\\) less cache misses, faster.\nbounded linear probing:\n\ninsert & find algorithms, invariants.\nremove is more difficult \\(\\Rightarrow\\) its implementation.\n\n\nintro to sorting\n\nintro to insertion sort.\n\n\n\n\nLecture 2\ndate:"
  },
  {
    "objectID": "ss24/alda/sum.html#week-6",
    "href": "ss24/alda/sum.html#week-6",
    "title": "Weekly Summary",
    "section": "Week 6",
    "text": "Week 6\n\nLecture 1\ndate: 20/05/24\n\nonline: Heap data structure\n\n\n\nLecture 2\ndate: 21/05/24\n\nprogramming example with compiler explorer: fibonacci iterative and recursive implementation, gcc optimization. (short detour: call stack) compiler can automatically implement tail recursion.\ninsertion algorithms:\n\ninsertion sort: pseudo-code implementation.\nmerge sort:\n\ndivide and conquer,\nmerging (\\(\\mathcal{O}(n))\\))\ntime-complexity of merge sort: assuming (without loss of generality) \\(n = 2^k\\) leads to master theorem. (wlog: we can extend a list to be \\(2^k\\))\n\n\\(\\Theta(n\\cdot\\log(n))\\) is the best we can do for comparison-based sorting\n\ndefinition of comparison-based sorting, fundamental operations\nany such algorithm must at least be able to differentiate between all \\(n!\\) permutations of the list \\(\\Rightarrow\\) lower-bound analysis via a comparison tree.\n\n\n\npartial integration\n\n\n\nquicksort: divide-and-conquer, but “reversed”\n\ncomplexity of quicksort (worst case is \\(\\mathcal{O}(n^2))\\)\nPivot is always the median \\(\\Rightarrow\\) \\(\\mathcal{O}(n\\cdot\\log{n})\\)\nproblem: finding the median (a good pivot) is not easy.\ncomplexity-analysis:"
  },
  {
    "objectID": "ss24/alda/sum.html#week-7",
    "href": "ss24/alda/sum.html#week-7",
    "title": "Weekly Summary",
    "section": "Week 7",
    "text": "Week 7\n\nLecture 1\ndate: 27/05/24\n\n\n\n\n\nLecture 2\ndate: 28/05/24\n\nexample: the c++ compiler optimizes calculation of middle value by generating assembly for r + (r - l) / 2 instead of (l + r) / 2, in order to reduce chance of overflow.\nquicksort with tail-recursion to reduce stack depth (revisiion of the previous lecture)\nquickselect algorithm from quicksort: can be used to determine the median of a sequence in \\(\\mathcal{O}(n)\\).\nsorting faster than \\(\\mathcal{\\Omega}(n\\log(n))\\) (without comparisons):\n\nKSort (Bucketsort), array implementation of bucketsort (in-place).\n\\(K^d\\) Sort: Least Significant Digit Radix Sorting.\n\nbinary search\n\nintermezzo: insertion sort in \\(\\mathcal{O}(\\log(n)\\cdot n)\\): library sort link"
  },
  {
    "objectID": "ss24/alda/sum.html#week-8",
    "href": "ss24/alda/sum.html#week-8",
    "title": "Weekly Summary",
    "section": "Week 8",
    "text": "Week 8\n\nLecture 1\ndate:\n\n\nLecture 2\ndate: 06/04/24\n\nc++ unique pointer implementation and move semantics\n(a, b) Trees - inserting"
  },
  {
    "objectID": "ss24/alda/sum.html#week-1-1",
    "href": "ss24/alda/sum.html#week-1-1",
    "title": "Weekly Summary",
    "section": "Week 1",
    "text": "Week 1\n\nLecture 1\ndate:\n\n\nLecture 2\ndate:"
  },
  {
    "objectID": "ss24/alda/sum.html#week-1-2",
    "href": "ss24/alda/sum.html#week-1-2",
    "title": "Weekly Summary",
    "section": "Week 1",
    "text": "Week 1\n\nLecture 1\ndate:\n\n\nLecture 2\ndate:"
  },
  {
    "objectID": "ss24/alda/sum.html#week-1-3",
    "href": "ss24/alda/sum.html#week-1-3",
    "title": "Weekly Summary",
    "section": "Week 1",
    "text": "Week 1\n\nLecture 1\ndate:\n\n\nLecture 2\ndate:"
  },
  {
    "objectID": "ss24/alda/sum.html#week-1-4",
    "href": "ss24/alda/sum.html#week-1-4",
    "title": "Weekly Summary",
    "section": "Week 1",
    "text": "Week 1\n\nLecture 1\ndate:\n\n\nLecture 2\ndate:"
  },
  {
    "objectID": "ss24/alda/sum.html#week-1-5",
    "href": "ss24/alda/sum.html#week-1-5",
    "title": "Weekly Summary",
    "section": "Week 1",
    "text": "Week 1\n\nLecture 1\ndate:\n\n\nLecture 2\ndate:"
  },
  {
    "objectID": "ss24/alda/sum.html#week-1-6",
    "href": "ss24/alda/sum.html#week-1-6",
    "title": "Weekly Summary",
    "section": "Week 1",
    "text": "Week 1\n\nLecture 1\ndate:\n\n\nLecture 2\ndate:"
  },
  {
    "objectID": "ss24/alda/sum.html#week-1-7",
    "href": "ss24/alda/sum.html#week-1-7",
    "title": "Weekly Summary",
    "section": "Week 1",
    "text": "Week 1\n\nLecture 1\ndate:\n\n\nLecture 2\ndate:"
  },
  {
    "objectID": "ss24/oop/exam1.html",
    "href": "ss24/oop/exam1.html",
    "title": "My Uni Notes",
    "section": "",
    "text": "OOP for Scientific Computing First Exam\npoints:\n\n\n\n1\n2\n3\n4\n5\n\\(\\Sigma\\)\n\n\n\n\n15\n20\n10\n10\n10\n65\n\n\n\nFollowing was asked in the exam:\n\nExplain following aspects of C++ :\n\nclass vs struct?\nnamespace. What is it, when & why is it used?\nprivate vs protected?\ncopy elision?\nheader guards. What, why?\nrule of five vs fule of zero?\ntemporaries? literals?\nhow does a shared pointer work?\nSFINAE?\nSOLID?\n\nShort code snippets were given and asked to explain & extend. With following topics:\n\ndefault function args\nconcepts\ntemplate parameters, default template parameters\nConstructor, copy constructor, copy assignment operator, move constructor, move assignment operator, overloaded constructor.\nLambda expression, functional programming\nCompile time branching\nCRTP\nInheritence. How to improve the given implementation\n\nHorner Schema: Variadic templates, recursion with templates(?), template metaprogramming\nAn incomplete implementation of an OOP system was given that was supposed to implement a simulation a prey-predator dynamic system, modeled by the Lotka-Volterra differential equations:\n\\[\\begin{align*}\n&\\frac{dx}{dt} = \\alpha x - \\beta xy, \\\\\n&\\frac{dy}{dt} = \\gamma y - \\delta xy\n\\end{align*}\\]\nThe incomplete OOP system had the following basic structure:\n\n\n\nLotka-Volterra OOP System\n\n\n\nImplement the PreyPredatorData Simulate(int steps, double dt) that creates a PreyPredatorData object, populates its members with the simulation data based on the Lotka-Volterra difference equations and returns the object:\n\n\\[\\begin{align*}\n&X_{n + 1} = X_n + \\Delta t (\\alpha x_n - \\beta x_ny_n) \\\\\n&Y_{n + 1} = Y_n + \\Delta t (\\delta x_ny_n- \\gamma y_n)\n\\end{align*}\\]\n\n?\n\n?"
  },
  {
    "objectID": "ss24/oop/plan.html#reading-list",
    "href": "ss24/oop/plan.html#reading-list",
    "title": "Study Plan",
    "section": "Reading List",
    "text": "Reading List\n\nBasic, General, Intro:\n\nBig C++. Cay Horstmann\nProgramming Principles & Practice with C++. Stroustrup.\nA Tour of C++. Stroustrup\nC++ Crash Course. Josh Lospinoso\nC++ Primer. Lippmann\n\nModern, General, Scientific:\n\nDiscovering Modern C++ 2nd ed. Gottschild.\nC++ STL. Josuttis\n\nModern, Specific:\n\nFunctional Programming in C++. Cukic\nMove Semantics. Josuttis\nC++ Templates. Vandervoorde\n\nOther:\n\nOOP in C++. Josuttis"
  },
  {
    "objectID": "ss24/r/index.html",
    "href": "ss24/r/index.html",
    "title": "R Programming",
    "section": "",
    "text": "R Programming and its Applications to Stochastic",
    "crumbs": [
      "R Programming"
    ]
  },
  {
    "objectID": "ss24/r/index.html#section",
    "href": "ss24/r/index.html#section",
    "title": "R Programming",
    "section": "",
    "text": "weekly summary\nnotes\nsolutions",
    "crumbs": [
      "R Programming"
    ]
  },
  {
    "objectID": "ss24/time/index.html",
    "href": "ss24/time/index.html",
    "title": "Time Log",
    "section": "",
    "text": "calendar (with week numbers) pertaining to this semester:\nUsage: cal [general options] [-jy] [[month] year]\n       cal [general options] [-j] [-m month] [year]\n       ncal -C [general options] [-jy] [[month] year]\n       ncal -C [general options] [-j] [-m month] [year]\n       ncal [general options] [-bhJjpwySM] [-H yyyy-mm-dd] [-s country_code] [-W number of days] [[month] year]\n       ncal [general options] [-Jeo] [year]\nGeneral options: [-31] [-A months] [-B months] [-d yyyy-mm]\nTwo main tags:"
  },
  {
    "objectID": "ss24/time/index.html#weekly",
    "href": "ss24/time/index.html#weekly",
    "title": "Time Log",
    "section": "Weekly",
    "text": "Weekly\n\ntotal times:\n\n\n\n                 Total\n2024  Week 31   15h45m\n      Week 32   14h10m\n              ========\n                29h55m\n\n\n\nalgorithms and data structures (#alda) and oop for scientific computing (#sci-oop):\n\n\n\n                 Total                   Total\n2024  Week 31    7h40m  2024  Week 31     8h5m\n      Week 32   10h25m        Week 32    4h15m\n              ========                ========\n                 18h5m                  12h20m"
  },
  {
    "objectID": "ss24/time/index.html#daily",
    "href": "ss24/time/index.html#daily",
    "title": "Time Log",
    "section": "Daily",
    "text": "Daily\n\ntotal:\n\n\n\n                       Total\n2024 Jul    Tue 30.     5h5m\n            Wed 31.       5h\n     Aug    Thu  1.    4h10m\n            Fri  2.    1h30m\n            Mon  5.    2h30m\n            Tue  6.    5h35m\n            Wed  7.    3h25m\n            Thu  8.    2h40m\n                    ========\n                      29h55m\n\n\n\n#alda and #sci-oop side by side;\n\n\n\n                       Total                           Total\n2024 Jul    Tue 30.    1h15m    2024 Jul    Tue 30.    3h50m\n            Wed 31.       4h                Wed 31.       1h\n     Aug    Thu  1.    2h25m         Aug    Thu  1.    1h45m\n            Mon  5.    2h30m                Fri  2.    1h30m\n            Tue  6.    2h50m                Tue  6.    2h45m\n            Wed  7.    3h25m                Thu  8.    1h30m\n            Thu  8.    1h10m                        ========\n            Fri  9.      30m                          12h20m\n                    ========    \n                       18h5m"
  },
  {
    "objectID": "ss24/time/index.html#entries",
    "href": "ss24/time/index.html#entries",
    "title": "Time Log",
    "section": "Entries",
    "text": "Entries\nTime log entries:\n\n\n\n2024-07-30 (6h!)\n#study #uni #exam\n    10:45 - 12:45 #sci-oop video reviews on moodle, Vid 1\n    -10m Break (#sci-oop)\n    14:00 - 15:45 #sci-oop video reviews on moodle, Vid 2\n    16:15 - 16:30 #sci-oop video reviews on moodle, Vid 2 \n        range based loops\n    16:30 - 17:45 #alda big #cpp sorting & serching\n\n2024-07-31 (6h!)\n#study #uni #exam\n    10:05 - 12:05 #alda big #cpp binary search ch 12\n    14:05 - 16:05 #alda big #cpp most frequent element ch 12\n        implemented most frequent element\n    16:35 - 17:35 #sci-oop move semantics ~ josuttis #cpp\n\n2024-08-01 (6h!)\n#study #uni #exam\n    10:35 - 13:15 #alda tutor notes, probleklausur\n    -15m Break (#alda)\n    14:45 - 16:45 #sci-oop move semantics ~ josuttis\n    -15m Break (#sci-oop)\n\n2024-08-02 (6h!)\n#study #uni #exam\n    10:45 - 12:45 #sci-oop move semantics ~ josuttis\n        finished ch 1.1\n    -30m Break (#sci-oop)\n\n2024-08-05 (6h!)\n#study #uni #exam\n    12:05 - 13:10 #alda big #cpp shell sort\n    -15m (#alda #cpp) Break\n    15:30 - 17:40 #alda big #cpp shell sort\n        implemented shell sort\n    -30m (#alda #cpp) Break\n\n2024-08-06\n    &lt;23:30 - 2:00 klog documentation\n    -45m Break & Distractions\n\n2024-08-06 (6h!)\n#study #uni #exam\n    9:45 - 11:15 #sci-oop move semantics \n        ch 1.2 - 1.5, 5p\n    11:35 - 12:50 #sci-oop move semantics ch 2\n        finished until summary chapter, 6p\n    14:45 - 15:35 #alda foundations of algorithms ~ neapolitan\n        preface & ch 1.0  \n    16:00 - 18:40 #alda foundations of algoroithms ~ neapolitan\n        ch 1.1 excluding matrix multiplication example\n    -40m #alda Break & Distractions\n\n2024-08-07 (5h30m!)\n#study #uni #exam\n    10:25 - 12:50 #alda foundations of algorithms ~ neapolitan\n        matrix multiplication example & ch 1.1\n        implemented & tested binary search\n    -20m #alda Break & Distractions\n    0m organized reading lists for ALDA and SCI-OOP \n        around 3.5 hours\n    18:00 - 19:20 #alda foundations of algorithms ~ neapolitan\n        ch1.2 fibonacci recursive and dynamic, impl and runtime\n\n2024-08-08 (4h!)\n#study #uni #exam\n    11:20 - 12:30 #alda implemented merge and mergesort\n        with proofs of correctness \n    0m sci-oop exam 14:20 - 16:00\n    17:00 - 18:30 #sci-oop typeset exam questions\n        and published them to the website\n\n2024-08-09\n    11:30 - 12:00 #alda typesetting first exam questions"
  },
  {
    "objectID": "ws23-24/ipi/ipi.html",
    "href": "ws23-24/ipi/ipi.html",
    "title": "IPI",
    "section": "",
    "text": "weekly summary\nnotes\nsolutions\ncourse website",
    "crumbs": [
      "IPI"
    ]
  },
  {
    "objectID": "ws23-24/num/num.html",
    "href": "ws23-24/num/num.html",
    "title": "Numerics 0",
    "section": "",
    "text": "weekly summary\nnotes\nsolutions",
    "crumbs": [
      "Numerics 0"
    ]
  }
]